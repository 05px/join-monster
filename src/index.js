import assert from 'assert'

import * as queryAST from './queryASTToSqlAST'
import arrToConnection from './arrToConnection'
import AliasNamespace from './aliasNamespace'
import nextBatch from './batchPlanner'
import { buildWhereFunction, handleUserDbCall, compileSqlAST } from './util'


/*         _ _ _                _    
  ___ __ _| | | |__   __ _  ___| | __
 / __/ _` | | | '_ \ / _` |/ __| |/ /
| (_| (_| | | | |_) | (_| | (__|   < 
 \___\__,_|_|_|_.__/ \__,_|\___|_|\_\
                                     
     _       __ _       _ _   _                 
  __| | ___ / _(_)_ __ (_) |_(_) ___  _ __  ___ 
 / _` |/ _ \ |_| | '_ \| | __| |/ _ \| '_ \/ __|
| (_| |  __/  _| | | | | | |_| | (_) | | | \__ \
 \__,_|\___|_| |_|_| |_|_|\__|_|\___/|_| |_|___/
*/

/**
 * User-defined function that sends a raw SQL query to the databse.
 * @callback dbCall
 * @param {String} sql - The SQL generated by `joinMonster` for the batch fetching. Use it to get the data from your database.
 * @param {Function} [done] - An error-first "done" callback. Only define this parameter if you don't want to return a `Promise`.
 * @returns {Promise.<Array>} The raw data as a flat array of objects. Each object must represent a row from the result set.
 */
/**
 * Function for generating a SQL expression.
 * @callback sqlExpr
 * @param {String} tableAlias - The alias generated for this table. Already double-quoted.
 * @param {Object} args - The GraphQL arguments for this field.
 * @param {Object} context - An Object with arbitrary contextual information.
 * @param {Array.<String>} parentAliases - List of aliases of the antecedent tables, starting with the parent field.
 * @returns {String} The expression interpolated into the query to compute the column.
 */
/**
 * Function for generating a `WHERE` condition.
 * @callback where
 * @param {String} tableAlias - The alias generated for this table. Already double-quoted.
 * @param {Object} args - The GraphQL arguments for this field.
 * @param {Object} context - An Object with arbitrary contextual information.
 * @param {Array.<String>} parentAliases - List of aliases of the antecedent tables, starting with the parent field.
 * @returns {String} The condition for the `WHERE` clause.
 */
/**
 * Function for generating a `JOIN` condition.
 * @callback sqlJoin
 * @param {String} parentTable - The alias generated for the parent's table. Already double-quoted.
 * @param {String} childTable - The alias for the child's table. Already double-quoted.
 * @param {Object} args - The GraphQL arguments for this field.
 * @param {Object} context - An Object with arbitrary contextual information.
 * @returns {String} The condition for the `LEFT JOIN`.
 */



/* _                _                                      
  | |__   ___  __ _(_)_ __    ___  ___  _   _ _ __ ___ ___ 
  | '_ \ / _ \/ _` | | '_ \  / __|/ _ \| | | | '__/ __/ _ \
  | |_) |  __/ (_| | | | | | \__ \ (_) | |_| | | | (_|  __/
  |_.__/ \___|\__, |_|_| |_| |___/\___/ \__,_|_|  \___\___|
              |___/                                        
*/

/**
 * Takes the GraphQL resolveInfo and returns a hydrated Object with the data.
 * @param {Object} resolveInfo - Contains the parsed GraphQL query, schema definition, and more. Obtained from the fourth argument to the resolver.
 * @param {Object} context - An arbitrary object that gets passed to the `where` function. Useful for contextual infomation that influeces the  `WHERE` condition, e.g. session, logged in user, localization.
 * @param {dbCall} dbCall - A function that is passed the compiled SQL that calls the database and returns (a promise of) the data.
 * @param {Object} [options]
 * @param {Boolean} options.minify - Generate minimum-length column names in the results table.
 * @param {String} options.dialect - The dialect of SQL your Database uses. Currently `'pg'`, `'mysql'`, and `'standard'` are supported.
 * @returns {Promise.<Object>} The correctly nested data from the database.
 */
async function joinMonster(resolveInfo, context, dbCall, options = {}) {
  // we need to read the query AST and build a new "SQL AST" from which the SQL and
  const sqlAST = queryAST.queryASTToSqlAST(resolveInfo, options)
  const { sql, shapeDefinition } = await compileSqlAST(sqlAST, context, options)
  if (!sql) return {}

  // call their function for querying the DB, handle the different cases, do some validation, return a promise of the object
  const data = arrToConnection(await handleUserDbCall(dbCall, sql, shapeDefinition), sqlAST)
  await nextBatch(sqlAST, data, dbCall, context, options)
  return data
}


/**
 * A helper for resolving the Node type in Relay.
 * @param {String} typeName - The Name of the GraphQLObjectType
 * @param {Object} resolveInfo - Contains the parsed GraphQL query, schema definition, and more. Obtained from the fourth argument to the resolver.
 * @param {Object} context - An arbitrary object that gets passed to the `where` function. Useful for contextual infomation that influeces the  WHERE condition, e.g. session, logged in user, localization.
 * @param {where|Number|String|Array} condition - A value to determine the `where` function for searching the node. If it's a function, that function will be used as the `where` function. Otherwise, it is assumed to be the value(s) of the `primaryKey`. An array of values is needed for composite primary keys.
 * @param {Function} dbCall - A function that is passed the compiled SQL that calls the database and returns (a promise of) the data.
 * @param {Object} [options] - Same as `joinMonster` function's options.
 * @returns {Promise.<Object>} The correctly nested data from the database. The GraphQL Type is added to the "\_\_type\_\_" property, which is helpful for the `resolveType` function in the `nodeDefinitions` of **graphql-relay-js**.
 */
async function getNode(typeName, resolveInfo, context, condition, dbCall, options = {}) {
  // get the GraphQL type from the schema using the name
  const type = resolveInfo.schema.getType(typeName)
  assert(type, `Type "${typeName}" not found in your schema.`)

  // we need to determine what the WHERE function should be
  let where = buildWhereFunction(type, condition, options)

  // our getGraphQLType expects every requested field to be in the schema definition. "node" isn't a parent of whatever type we're getting, so we'll just wrap that type in an object that LOOKS that same as a hypothetical Node type
  const fakeParentNode = {
    _fields: {
      node: {
        type,
        name: type.name.toLowerCase(),
        where
      }
    }
  }
  const namespace = new AliasNamespace(options.minify)
  const sqlAST = {}
  const fieldNodes = resolveInfo.fieldNodes || resolveInfo.fieldASTs
  // uses the same underlying function as the main `joinMonster`
  queryAST.getGraphQLType(fieldNodes[0], fakeParentNode, sqlAST, resolveInfo.fragments, resolveInfo.variableValues, namespace, 0, options)
  queryAST.pruneDuplicateSqlDeps(sqlAST, namespace)
  const { sql, shapeDefinition } = await compileSqlAST(sqlAST, context, options)
  const data = arrToConnection(await handleUserDbCall(dbCall, sql, shapeDefinition), sqlAST)
  await nextBatch(sqlAST, data, dbCall, context, options)
  if (!data) return data
  data.__type__ = type
  return data
}

joinMonster.getNode = getNode



// expose the package version for debugging
joinMonster.version = require('../package.json').version
export default joinMonster

