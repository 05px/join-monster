import util from 'util'
import assert from 'assert'
import { nest } from 'nesthydrationjs'
import { groupBy, map, flatMap, uniq, forIn, chain } from 'lodash'
const debug = require('debug')('join-monster')

import * as queryAST from './queryASTToSqlAST'
import defineObjectShape from './defineObjectShape'
import arrToConnection from './arrToConnection'
import AliasNamespace from './aliasNamespace'
import { emphasize, inspect, buildWhereFunction, wrap, maybeQuote } from './util'


/*         _ _ _                _    
  ___ __ _| | | |__   __ _  ___| | __
 / __/ _` | | | '_ \ / _` |/ __| |/ /
| (_| (_| | | | |_) | (_| | (__|   < 
 \___\__,_|_|_|_.__/ \__,_|\___|_|\_\
                                     
     _       __ _       _ _   _                 
  __| | ___ / _(_)_ __ (_) |_(_) ___  _ __  ___ 
 / _` |/ _ \ |_| | '_ \| | __| |/ _ \| '_ \/ __|
| (_| |  __/  _| | | | | | |_| | (_) | | | \__ \
 \__,_|\___|_| |_|_| |_|_|\__|_|\___/|_| |_|___/
*/

/**
 * User-defined function that sends a raw SQL query to the databse.
 * @callback dbCall
 * @param {String} sql - The SQL generated by `joinMonster` for the batch fetching. Use it to get the data from your database.
 * @param {Function} [done] - An error-first "done" callback. Only define this parameter if you don't want to return a `Promise`.
 * @returns {Array|Promise.<Array>} The raw data as a flat array of objects. Each object must represent a row from the result set.
 */
/**
 * Function for generating a SQL expression.
 * @callback sqlExpr
 * @param {String} tableAlias - The alias generated for this table. Already double-quoted.
 * @param {Object} args - The GraphQL arguments for this field.
 * @param {Object} context - An Object with arbitrary contextual information.
 * @param {Array.<String>} parentAliases - List of aliases of the antecedent tables, starting with the parent field.
 * @returns {String} The expression interpolated into the query to compute the column.
 */
/**
 * Function for generating a `WHERE` condition.
 * @callback where
 * @param {String} tableAlias - The alias generated for this table. Already double-quoted.
 * @param {Object} args - The GraphQL arguments for this field.
 * @param {Object} context - An Object with arbitrary contextual information.
 * @param {Array.<String>} parentAliases - List of aliases of the antecedent tables, starting with the parent field.
 * @returns {String} The condition for the `WHERE` clause.
 */
/**
 * Function for generating a `JOIN` condition.
 * @callback sqlJoin
 * @param {String} parentTable - The alias generated for the parent's table. Already double-quoted.
 * @param {String} childTable - The alias for the child's table. Already double-quoted.
 * @param {Object} context - An Object with arbitrary contextual information.
 * @returns {String} The condition for the `LEFT JOIN`.
 */


/* _                _                                      
  | |__   ___  __ _(_)_ __    ___  ___  _   _ _ __ ___ ___ 
  | '_ \ / _ \/ _` | | '_ \  / __|/ _ \| | | | '__/ __/ _ \
  | |_) |  __/ (_| | | | | | \__ \ (_) | |_| | | | (_|  __/
  |_.__/ \___|\__, |_|_| |_| |___/\___/ \__,_|_|  \___\___|
              |___/                                        
*/


/**
 * Takes the GraphQL resolveInfo and returns a hydrated Object with the data.
 * @param {Object} resolveInfo - Contains the parsed GraphQL query, schema definition, and more. Obtained from the fourth argument to the resolver.
 * @param {Object} context - An arbitrary object that gets passed to the `where` function. Useful for contextual infomation that influeces the  `WHERE` condition, e.g. session, logged in user, localization.
 * @param {dbCall} dbCall - A function that is passed the compiled SQL that calls the database and returns (a promise of) the data.
 * @param {Object} [options]
 * @param {Boolean} options.minify - Generate minimum-length column names in the results table.
 * @param {String} options.dialect - The dialect of SQL your Database uses. Currently `'pg'`, `'mysql'`, and `'standard'` are supported.
 * @returns {Promise.<Object>} The correctly nested data from the database.
 */
async function joinMonster(resolveInfo, context, dbCall, options = {}) {
  // we need to read the query AST and build a new "SQL AST" from which the SQL and
  const sqlAST = queryAST.queryASTToSqlAST(resolveInfo, options)
  const { sql, shapeDefinition } = await compileSqlAST(sqlAST, context, options)
  if (!sql) return {}

  // call their function for querying the DB, handle the different cases, do some validation, return a promise of the object
  const data = arrToConnection(await handleUserDbCall(dbCall, sql, shapeDefinition), sqlAST)
  await nextBatch(sqlAST, data, dbCall, context, options)
  return data
}

async function nextBatch(sqlAST, data, dbCall, context, options) {
  // paginated fields are wrapped in connections. strip those off for the batching
  if (sqlAST.paginate) {
    if (Array.isArray(data)) {
      data = chain(data).flatMap('edges').map('node').value()
    } else {
      data = map(data.edges, 'node')
    }
  }
  if (!data || (Array.isArray(data) && data.length === 0)) {
    return 
  }

  // loop through all the child fields that are tables
  for (let childAST of sqlAST.children) {
    if (childAST.type === 'table') {
      const fieldName = childAST.fieldName
      // see if any begin a new batch
      if (childAST.sqlBatch) {
        childAST.children.push(childAST.sqlBatch.thisKey)
        const thisField = childAST.sqlBatch.thisKey.fieldName
        const parentField = childAST.sqlBatch.parentKey.fieldName
        if (Array.isArray(data)) {
          const batchScope = uniq(data.map(obj => maybeQuote(obj[parentField])))
          const { sql, shapeDefinition } = await compileSqlAST(childAST, context, { ...options, batchScope } )
          let newData = await handleUserDbCall(dbCall, sql, wrap(shapeDefinition))
          newData = groupBy(newData, thisField)
          if (childAST.paginate) {
            forIn(newData, (group, key, obj) => {
              obj[key] = arrToConnection(group, childAST)
            })
          }
          if (childAST.grabMany) {
            for (let obj of data) {
              obj[fieldName] = newData[obj[parentField]] || []
            }
          } else {
            for (let obj of data) {
              obj[fieldName] = arrToConnection(newData[obj[parentField]][0], childAST)
            }
          }
          const nextLevelData = flatMap(data, obj => obj[fieldName])
          await nextBatch(childAST, nextLevelData, dbCall, context, options)
        } else {
          const batchScope = [ data[parentField] ]
          const { sql, shapeDefinition } = await compileSqlAST(childAST, context, { ...options, batchScope } )
          let newData = await handleUserDbCall(dbCall, sql, wrap(shapeDefinition))
          newData = groupBy(newData, thisField)
          if (childAST.paginate){
            const targets = newData[data[parentField]]
            data[fieldName] = arrToConnection(targets, childAST)
          } else {
            if (childAST.grabMany) {
              data[fieldName] = newData[data[parentField]] || []
            } else {
              const targets = newData[data[parentField]] || []
              data[fieldName] = targets[0]
            }
          }
          await nextBatch(childAST, data[fieldName], dbCall, context, options)
        }
      } else {
        if (Array.isArray(data)) {
          const nextLevelData = flatMap(data, obj => obj[fieldName])
          await nextBatch(childAST, nextLevelData, dbCall, context, options)
        } else {
          if (data) {
            await nextBatch(childAST, data[fieldName], dbCall, context, options)
          }
        }
      }
    }
  }
}



async function compileSqlAST(sqlAST, context, options) {
  debug(emphasize('SQL_AST'), inspect(sqlAST))

  // now convert the "SQL AST" to sql
  const dialect = options.dialect || 'standard'
  const stringify = require('./stringifiers/' + dialect).default
  const sql = await stringify(sqlAST, context, options.batchScope)
  debug(emphasize('SQL'), sql)

// figure out the shape of the object and define it for the NestHydration library so it can build the object nesting
  const shapeDefinition = defineObjectShape(sqlAST)
  debug(emphasize('SHAPE_DEFINITION'), inspect(shapeDefinition))
  return { sql, shapeDefinition }
}


/**
 * A helper for resolving the Node type in Relay.
 * @param {String} typeName - The Name of the GraphQLObjectType
 * @param {Object} resolveInfo - Contains the parsed GraphQL query, schema definition, and more. Obtained from the fourth argument to the resolver.
 * @param {Object} context - An arbitrary object that gets passed to the `where` function. Useful for contextual infomation that influeces the  WHERE condition, e.g. session, logged in user, localization.
 * @param {where|Number|String|Array} condition - A value to determine the `where` function for searching the node. If it's a function, that function will be used as the `where` function. Otherwise, it is assumed to be the value(s) of the `primaryKey`. An array of values is needed for composite primary keys.
 * @param {Function} dbCall - A function that is passed the compiled SQL that calls the database and returns (a promise of) the data.
 * @param {Object} [options] - Same as `joinMonster` function's options.
 * @returns {Promise.<Object>} The correctly nested data from the database. The GraphQL Type is added to the "\_\_type\_\_" property, which is helpful for the `resolveType` function in the `nodeDefinitions` of **graphql-relay-js**.
 */
async function getNode(typeName, resolveInfo, context, condition, dbCall, options = {}) {
  // get the GraphQL type from the schema using the name
  const type = resolveInfo.schema.getType(typeName)
  assert(type, `Type "${typeName}" not found in your schema.`)

  // we need to determine what the WHERE function should be
  let where = buildWhereFunction(type, condition, options)

  // our getGraphQLType expects every requested field to be in the schema definition. "node" isn't a parent of whatever type we're getting, so we'll just wrap that type in an object that LOOKS that same as a hypothetical Node type
  const fakeParentNode = {
    _fields: {
      node: {
        type,
        name: type.name.toLowerCase(),
        where
      }
    }
  }
  const namespace = new AliasNamespace(options.minify)
  const sqlAST = {}
  const fieldNodes = resolveInfo.fieldNodes || resolveInfo.fieldASTs
  // uses the same underlying function as the main `joinMonster`
  queryAST.getGraphQLType(fieldNodes[0], fakeParentNode, sqlAST, resolveInfo.fragments, resolveInfo.variableValues, namespace, options)
  queryAST.pruneDuplicateSqlDeps(sqlAST, namespace)
  const { sql, shapeDefinition } = await compileSqlAST(sqlAST, context, options)
  const data = arrToConnection(await handleUserDbCall(dbCall, sql, shapeDefinition), sqlAST)
  await nextBatch(sqlAST, data, dbCall, context, options)
  if (!data) return data
  data.__type__ = type
  return data
}

joinMonster.getNode = getNode

// handles the different callback signatures and return values.
function handleUserDbCall(dbCall, sql, shapeDefinition) {
  // if there are two args, we're in "callback mode"
  if (dbCall.length === 2) {
    // wrap it in a promise
    return new Promise((resolve, reject) => {
      // wait for them to call "done"
      dbCall(sql, (err, rows) => {
        if (err) {
          reject(err)
        } else {
          rows = validate(rows)
          debug(emphasize('RAW_DATA'), inspect(rows.slice(0, 8)))
          debug(`${rows.length} rows...`)
          resolve(nest(rows, shapeDefinition))
        }
      })
    })
  }

  const result = dbCall(sql)
  // if their func gave us a promise for the data, wait for the data
  if (typeof result.then === 'function') {
    return result.then(rows => {
      rows = validate(rows)
      debug(emphasize('RAW DATA'), inspect(rows.slice(0, 8)))
      debug(`${rows.length} rows...`)
      return nest(rows, shapeDefinition)
    })
  } else {
    throw new Error('must return a promise of the data or use the callback')
  }
}

// validate the data they gave us
function validate(rows) {
  // its supposed to be an array of objects
  if (Array.isArray(rows)) return rows
  // a check for the most common error. a lot of ORMs return an object with the desired data on the `rows` property
  else if (rows && rows.rows) return rows.rows
  else {
    throw new Error(`"dbCall" function must return/resolve an array of objects where each object is a row from the result set. Instead got ${util.inspect(rows, { depth: 3 })}`)
  }
}

// expose the package version for debugging
joinMonster.version = require('../package.json').version
export default joinMonster

